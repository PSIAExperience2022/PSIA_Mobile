//
//  HomeView.swift
//  PKOC Companion
//
//  Created by Nihir Singh on 1/19/23.
//

import SwiftUI
import CoreBluetooth
import CryptoKit

struct HomeView: View {
    
    //@State var bluetoothController: BluetoothController = BluetoothController()
    @ObservedObject var bluetoothController: BluetoothController
    var perpherial: CBPeripheral
    
    @Environment(\.isPresented) var isPresented // when back is pressed, this gets set to false
    
    @State var isLocked: Bool = true
    @State var isLoading: Bool = false
    @State var dragEnded: Bool = false
    
    @State private var nonce: Data? // on startup, we will not have a nonce or signature
    @State private var signature: Data?
    
    func connectToPKOC() {
        print("Trying to connect to a PKOC Reader")
//        bluetoothController.connectPKOCReader(PKOCperipheral: perpherial)
        bluetoothController.readNonce()
        isLoading = true
//        DispatchQueue.main.asyncAfter(deadline: .now() + 2, execute: {
//            // MARK: Ask Reader for Nonce (number only used once, generated by lock)
//            bluetoothController.readNonce()
//            print("Sending nonce signature to lock, avoiding shit in the middle")
//            // MARK: We sign nonce with our private key
//            sendNonceSignatureToLock()
//        })
    }
    
    func sendNonceSignatureToLock() {
        guard self.nonce != nil else {
            // if nonce is nil, this will execute
            print("Nonce should not be NULL, what happened?")
            return
        }
                
        // signing the nonce from reader with our private key, which is stored on our device
//        AuthenticationManager.signNonceWithPrivateKey(nonce: nonce!, { result in
//            switch result {
//            case .success(let data):
//                self.signature = data // got back signed signature, woohoo
//            case .failure(let err):
//                print(err.localizedDescription)
//            }
//        })
        
        guard self.signature != nil else {
            print("You literally just created a signature, unless it failed.")
            return
        }
        
        // Need to pack a hex buffer a particular way,
        // Type (0x01) | Length (1-byte to describe) | Value | Type (0x03) | Length (1-byte to describe) | Value
        
        let typePublicKey = String(format:"%02X", 1)
        print("value of public key (hex)is: \(typePublicKey)")
        let lengthPublicKey = String(format:"%02X", 32)
        print("value of public key length (hex)is: \(lengthPublicKey)")
        
        // represent public key as a collection of bytes
        let publicKey = AuthenticationManager.exportPublicKey().rawRepresentation
        print("Public key value value: \(AuthenticationManager.exportPublicKey().rawRepresentation)")
                
        let typeDigitalSignature = String(format: "%02X", 3)
        print("value of digital signature (hex)is: \(typeDigitalSignature)")
        let lengthDigitalSignature = String(format: "%02X", 64)
        
        print("valueToSendToReader (as base64EncodedString): \(signature!.base64EncodedString())")
        print("valueToSendToReader (as hexEncodedString: \(signature!.hexEncodedString1())")
        
        // our handcrafted buffer to send to the reader, per PKOC specs
        // 0x20 is the length of the Public Key (32 bytes) and 0x40 is the length of the digitalSignature (64 bytes)
        let buffer: [String] = ["0x01", "0x20", publicKey.hexEncodedString1(), "0x03", "0x40", signature!.hexEncodedString1()]
        
        // make buffer into a byte array
        let valueToSendToReader = NSData(bytes: buffer, length: buffer.count)
        
        // as Data means it is raw, binary data
        bluetoothController.write(value: valueToSendToReader as Data, characteristic: bluetoothController.PKOCwriteCharactertistic!)
        
        self.isLoading = false
    }
    
    func disconnectPeripheral() {
        print("Trying to disconnect connected peripheral")
        bluetoothController.disconnectPeripheral(PKOCperipheral: perpherial)
    }
    
    func loadingTasks() {
        AuthenticationManager.generateAndSendPublishKey { _ in
            print("Generated Public key")
        }
        bluetoothController.startScanning()
        DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {
            print("Turning BL scan off after 4 seconds")
            bluetoothController.stopScanning()
        }
    }
        
    func logoutUser() {
        AuthenticationManager.isUserAuthenticated.send(false)
    }
    
    func convert(_ str: String, fromRadix r1: Int, toRadix r2: Int) -> String? {
        if let num = Int(str, radix: r1) {
            return String(num, radix: r2)
        } else {
            return nil
        }
    }
    
    
    var body: some View {
        ZStack {
            Color.primaryBackground.ignoresSafeArea()
            VStack {
                Group {
                    Image("PSIAExperience")
                        .resizable()
                        .frame(width: 220, height: 130, alignment: .top)
                }
                .padding(.top)
                .padding(.leading, 34)
                
                Spacer()
                                
                VStack {
                    if isLocked {
                        LottieView(lottieFile: "lockAnimation", speed: 0, loopMode: .playOnce, reverse: true)
                    }
                    if (dragEnded) {
                        LottieView(lottieFile: "lockAnimation", speed: 0.7, loopMode: .playOnce, reverse: true)
                    }
                    if (isLocked && dragEnded) {
                            LottieView(lottieFile: "lockAnimation", speed: 0, loopMode: .playOnce, reverse: true)
                    }
                }
                
                Spacer()
                
                SlideToUnlock(isLocked: $isLocked, isLoading: isLoading, hasEnded: $dragEnded) { result in
                    switch(result) {
                    case 0:
                        print("Unlocked, starting PKOC Lock connection")
                        connectToPKOC()
                    case 1:
                        print("Locked, disconnecting from PKOC lock")
                        disconnectPeripheral()
                    default:
                        print("Eh What?")
                    }
                }
                .padding(.bottom, 60)
            }
        }
        .onChange(of: isPresented) { newValue in
            if !newValue {
                print("HomeView is dismissed, disconnecting from PKOC lock")
                disconnectPeripheral()
            }

        }
        .onAppear() {
            bluetoothController.connectPKOCReader(PKOCperipheral: self.perpherial)
        }
    }
}


//struct HomeView_Previews: PreviewProvider {
//    var bluetoothController: BluetoothController
//
//    static var previews: some View {
//        HomeView(bluetoothController: bluetoothController, perpherial: bluetoothController.PKOCperipheral).preferredColorScheme(.dark)
//    }
//}


//    func generateSigningKey() {
//        let signingKey = Curve25519.Signing.PrivateKey()
//        /*:
//         Get a data representation of the public key.
//         */
//        let signingPublicKey = signingKey.publicKey
//        let signingPublicKeyData = signingPublicKey.rawRepresentation
//
//        print("signingPublicKey: \(signingPublicKey)")
//        print("signingPublicKeyData: \(signingPublicKeyData.base64EncodedString())")
////        /*:
////         Initialize a public key from its raw representation.
////         */
////        let initializedSigningPublicKey = try! Curve25519.Signing.PublicKey(rawRepresentation: signingPublicKeyData)
////        /*:
////         Use the private key to generate a signature.
////         */
////        let dataToSign = "Some sample Data to sign.".data(using: .utf8)!
////        let signature = try! signingKey.signature(for: dataToSign)
////        /*:
////         Verify the signature with the public key.
////         */
////        if initializedSigningPublicKey.isValidSignature(signature, for: dataToSign) {
////            print("The signature is valid.")
////        }
//    }
